# Context-Free Grammar for badlang

## TERMINALS

# Keywords
INT: "int"
BOOL: "bool"
FUN: "fun"
IF: "if"
ELSE: "else"
WHILE: "while"
RETURN: "return"
PRINT: "print"
TRUE: "true"
FALSE: "false"

# Identifiers
ID: [a-zA-Z_][a-zA-Z0-9_]*

# Literals
INT_LITERAL: [0-9]+
BOOL_LITERAL: TRUE | FALSE

# Operators
PLUS: "+"
MINUS: "-"
MULTIPLY: "*"
DIVIDE: "/"
ASSIGN: "="
EQUAL: "=="
NOT_EQUAL: "!="
LESS: "<"
LESS_EQUAL: "<="
GREATER: ">"
GREATER_EQUAL: ">="
AND: "&&"
OR: "||"
NOT: "!"

# Punctuation
LPAREN: "("
RPAREN: ")"
LBRACE: "{"
RBRACE: "}"
COMMA: ","
SEMICOLON: ";"

## NON-TERMINALS and PRODUCTION RULES

program → stmt* EOF

params → type ID (COMMA type ID)*
callParams → expression (COMMA expression)*
type → INT | BOOL
block → LBRACE stmt* RBRACE

stmt → blockStmt | exprStmt | funStmt | printStmt | ifStmt | returnStmt | varStmt | assignStmt | whileStmt

blockStmt → block
exprStmt → expression SEMICOLON
funStmt → FUN type ID LPAREN params? RPAREN block
printStmt → PRINT expression SEMICOLON
ifStmt → IF LPAREN expression RPAREN block (ELSE block)?
returnStmt → RETURN expression? SEMICOLON
varStmt → type ID (ASSIGN expression)? SEMICOLON
assignStmt → ID ASSIGN expression SEMICOLON
whileStmt → WHILE LPAREN expression RPAREN block

expression → binExpr | litExpr | unaryExpr | varExpr | callExpr | parenExpr

binExpr → expression (
	PLUS | MINUS | MULTIPLY | DIVIDE | 
	EQUAL | NOT_EQUAL | LESS | LESS_EQUAL | GREATER | GREATER_EQUAL | 
	AND | OR) expression
litExpr → INT_LITERAL | BOOL_LITERAL
unaryExpr → (MINUS | NOT) expression
varExpr → ID
callExpr → ID LPAREN callParams? RPAREN
parenExpr → LPAREN expression RPAREN